Spring Boot 
is a framework that simplifies Spring by removing boilerplate configuration. It provides auto-configuration, embedded servers, and starter dependencies, making apps production-ready quickly.

2) Why Spring Boot over Spring Framework?
Auto Configuration ‚Äì No need of manual XML config.
Embedded Server ‚Äì Run as a standalone JAR (no need to deploy in external server).
Starter Dependencies ‚Äì Just add ‚Äústarter‚Äù in pom (e.g., spring-boot-starter-web).
Production Ready ‚Äì Health checks, metrics (via Actuator).
Minimal Configuration ‚Äì Only properties file changes.
Part of Spring Ecosystem ‚Äì Works with Spring Security, Data JPA, Cloud, etc.
üëâ Simple: Spring Boot = Spring + Auto setup + Embedded Server.

3) How does Spring Boot work?
Add starter dependencies in pom.xml.
Spring Boot auto-configures beans based on dependencies.
Creates IoC container & manages beans.
Starts embedded server automatically.

4) Flow of a Spring Boot App
Project Setup (Spring Initializr, Maven, Gradle).
Dependencies (starters like web, jpa).
Main class ‚Üí @SpringBootApplication ‚Üí main() ‚Üí app starts.
Component Scanning (detects @Component, @Service, @Repository).
Auto Configuration (based on dependencies).
Dependency Injection (using @Autowired, @Bean).
Request Handling (@RestController, @Controller).
Business Logic (Service + Repository).
Embedded Server starts (Tomcat/Jetty).
Production ready features (logging, health, metrics).5)SB Annoations

---------------------------------------------------------------------------------------------------------
üîπ @SpringBootApplication
     Main entry point of a Spring Boot app.
     It is a combination of 3 annotations:

@Configuration
@EnableAutoConfiguration
@ComponentScan

When you add this on the main class, Spring Boot:
Marks the class as configuration provider.
Auto-configures beans based on dependencies.
Scans the package for components (services, repos, controllers).
üëâ Think of it as the "starting engine" of Spring Boot apps.

üîπ @Configuration
   Tells Spring: ‚ÄúThis class has bean definitions.‚Äù
   Replaces old XML config files.
   You can use @Bean inside it to manually create beans.
   üëâ Think: a place where we define how beans should be created.

üîπ @EnableAutoConfiguration
    Tells Spring Boot to automatically configure beans depending on the dependencies present in classpath.
    Example: If you add spring-boot-starter-web, Spring Boot automatically:
    Configures Tomcat as server.
    Sets up DispatcherServlet.
    Prepares JSON converters. 
   üëâ Think: Spring Boot guesses and configures things for you.

üîπ @ComponentScan
   Scans the package and sub-packages of the class where it‚Äôs written.
   Finds classes annotated with:
   @Component @Service  @Repository  @Controller
   Automatically registers them as beans in Spring‚Äôs IoC container.
   üëâ Think: It‚Äôs like a scanner that finds beans and makes them available in the app.

üîπ @Bean
    Used inside a @Configuration class.
    It tells Spring: ‚ÄúThis method returns a bean that Spring should manage.‚Äù

Example:
@Configuration
public class AppConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();  // Spring will manage this object
    }
}

@Component:it is used to mark a class as a spring bean that will be managed by the spring container.
@Autowired: Automatically injects beans.
@Service: used to annotated classes that contain business logic.
@Repository: Marks a class as a Data Access Object (DAO).

@RestController: 
Combines @Controller and @ResponseBody for REST APIs.
Combines @Controller and @ResponseBody. It marks a class as a REST API controller where methods return JSON or XML directly (not views).

@Controller:
Marks a class as a Spring MVC controller. Methods in this class return a view name (like an HTML page).

@ResponseBody
Indicates that the return value of a method should be serialized directly to the HTTP response body (e.g., as JSON).

@RequestMapping:
is used to map HTTP requests to controller classes or methods. It can specify the URL path, HTTP methods, parameters, etc.
is versatile but can be replaced with more specific annotations for better readability in Spring Boot.

@GetMapping:
Use @GetMapping when you need to retrieve or read data in REST APIs.
Handles HTTP GET requests directly.
Reduces boilerplate code compared to @RequestMapping.
Supports path variables, query parameters, headers, and JSON responses.

@PostMapping:
used to handle HTTP POST requests. It‚Äôs typically used to create or submit data, such as creating a new resource in a REST API.
Handles HTTP POST requests directly.
Simplifies handling request bodies using @RequestBody.
Easily combines with @PathVariable, @RequestParam, and headers.

@PutMapping:
is a Spring annotation used to handle HTTP PUT requests. It is generally used to update or replace an existing resource on the server.
Used to completely replace an existing resource. All fields of the resource are updated, and any missing fields are typically set to null.
PUT = Full update

@PatchMapping: 
Used to partially update an existing resource. Only the fields specified in the request are updated, not the whole resource.
PATCH = Partial update


@DeleteMapping: 
handling HTTP DELETE requests.For deleting data.

@RequestBody:
is used to bind the HTTP request body to a Java object. It tells Spring to deserialize the incoming request data (usually in JSON or XML format) into an object.
Used to deserialize the request body into a Java object.
Commonly used in REST APIs (in POST and PUT methods) to handle the data sent from clients.
Automatically works with JSON (or other media types if configured).
Custom serializers/deserializers can be configured for more advanced use cases.

Serialization: Converting Java objects into JSON.
Deserialization: Converting JSON data into Java objects.
This process is automatic when using @RequestBody (deserialization) and returning objects in controller methods (serialization).


@PathVariable:
is used in Spring Boot to bind URL template variables in your request URL to method parameters. It is commonly used in REST APIs when you need to extract dynamic data (like IDs, usernames, etc.) from the URL path.

@RequestParam:
is used in Spring Boot to extract query parameters from the URL. It binds the value of a query parameter to a method parameter in your controller.
Use @RequestParam for data passed in the query string (?key=value).
It‚Äôs commonly used in filtering, searching, or passing extra information to an API.
For parameters in the URL path, use @PathVariable.

@RequestHeader:
Use @RequestHeader when you need information like:
Authentication tokens (Authorization headers).
User information (User-Agent).
Content negotiation details (Accept, Content-Type).
It is helpful in building APIs where header values contain important metadata.


@RequestAttribute: 
 simplifies passing shared information between layers in a Spring Boot application, making your architecture cleaner and more maintainable.

@Required:
Ensures that a bean property (set through a setter method) must be provided a value during Spring configuration. If the property isn‚Äôt set, the application will throw a BeanInitializationException.
Only works with XML-based configuration (deprecated in Spring 5). For modern Spring applications, use constructor injection or @Autowired with validations instead.

@Qualifier
in Spring is used to differentiate between multiple beans of the same type. When you have multiple beans of the same type in your application context, @Qualifier helps the framework decide which one to use in dependency injection.

@Lazy:
The @Lazy annotation in Spring delays the initialization of a bean until it is first used. By default, Spring initializes all singleton beans during application startup. Marking a bean as @Lazy tells Spring to initialize it on-demand rather than at startup.


ResponseEntity

6)Spring Boot Starters
Spring Boot Starters are ready-to-use dependencies for adding specific features (e.g., web, database, or security) to your application, reducing complexity and speeding up development.


7)key dependencies of SP
spring-boot-starter-parent
spring-boot-maven-plugin
spring-boot-starter-test,security,actuater,web,jpa




